{
  "version": 3,
  "sources": ["../src/auth.ts", "../src/ratelimit.ts", "../src/openai.ts", "../src/index.ts"],
  "sourceRoot": "dist",
  "sourcesContent": ["import { Env, TokenPayload } from './types';\n\n// Simple JWT implementation for Cloudflare Workers\n// Uses Web Crypto API available in Workers\n\nconst encoder = new TextEncoder();\n\nfunction base64UrlEncode(data: Uint8Array): string {\n  const base64 = btoa(String.fromCharCode(...data));\n  return base64.replace(/\\+/g, '-').replace(/\\//g, '_').replace(/=/g, '');\n}\n\nfunction base64UrlDecode(str: string): Uint8Array {\n  const base64 = str.replace(/-/g, '+').replace(/_/g, '/');\n  const padding = '='.repeat((4 - base64.length % 4) % 4);\n  const binary = atob(base64 + padding);\n  return Uint8Array.from(binary, c => c.charCodeAt(0));\n}\n\nasync function getKey(secret: string): Promise<CryptoKey> {\n  return crypto.subtle.importKey(\n    'raw',\n    encoder.encode(secret),\n    { name: 'HMAC', hash: 'SHA-256' },\n    false,\n    ['sign', 'verify']\n  );\n}\n\nexport async function createToken(payload: Omit<TokenPayload, 'iat' | 'exp'>, secret: string, expiresInDays = 365): Promise<string> {\n  const now = Math.floor(Date.now() / 1000);\n  const fullPayload: TokenPayload = {\n    ...payload,\n    iat: now,\n    exp: now + (expiresInDays * 24 * 60 * 60),\n  };\n\n  const header = { alg: 'HS256', typ: 'JWT' };\n  const headerB64 = base64UrlEncode(encoder.encode(JSON.stringify(header)));\n  const payloadB64 = base64UrlEncode(encoder.encode(JSON.stringify(fullPayload)));\n\n  const key = await getKey(secret);\n  const signature = await crypto.subtle.sign(\n    'HMAC',\n    key,\n    encoder.encode(`${headerB64}.${payloadB64}`)\n  );\n\n  const signatureB64 = base64UrlEncode(new Uint8Array(signature));\n  return `${headerB64}.${payloadB64}.${signatureB64}`;\n}\n\nexport async function verifyToken(token: string, secret: string): Promise<TokenPayload | null> {\n  try {\n    const parts = token.split('.');\n    if (parts.length !== 3) return null;\n\n    const [headerB64, payloadB64, signatureB64] = parts;\n\n    const key = await getKey(secret);\n    const signature = base64UrlDecode(signatureB64);\n    \n    const valid = await crypto.subtle.verify(\n      'HMAC',\n      key,\n      signature,\n      encoder.encode(`${headerB64}.${payloadB64}`)\n    );\n\n    if (!valid) return null;\n\n    const payload: TokenPayload = JSON.parse(\n      new TextDecoder().decode(base64UrlDecode(payloadB64))\n    );\n\n    // Check expiration\n    if (payload.exp < Math.floor(Date.now() / 1000)) {\n      return null;\n    }\n\n    return payload;\n  } catch {\n    return null;\n  }\n}\n\nexport function generateDeviceId(): string {\n  const bytes = new Uint8Array(16);\n  crypto.getRandomValues(bytes);\n  return Array.from(bytes, b => b.toString(16).padStart(2, '0')).join('');\n}\n", "import { Env, RateLimitEntry } from './types';\n\nconst RATE_LIMIT_PREFIX = 'rate:';\n\nfunction getTodayKey(deviceId: string): string {\n  const today = new Date().toISOString().split('T')[0];\n  return `${RATE_LIMIT_PREFIX}${deviceId}:${today}`;\n}\n\nfunction getTomorrowReset(): string {\n  const tomorrow = new Date();\n  tomorrow.setUTCDate(tomorrow.getUTCDate() + 1);\n  tomorrow.setUTCHours(0, 0, 0, 0);\n  return tomorrow.toISOString();\n}\n\nexport async function checkRateLimit(\n  env: Env,\n  deviceId: string,\n  isPremium: boolean\n): Promise<{ allowed: boolean; used: number; limit: number; resetsAt: string }> {\n  // Premium users have unlimited\n  if (isPremium) {\n    return {\n      allowed: true,\n      used: 0,\n      limit: -1, // Unlimited\n      resetsAt: '',\n    };\n  }\n\n  const limit = parseInt(env.FREE_DAILY_LIMIT) || 3;\n  const key = getTodayKey(deviceId);\n  \n  const entry = await env.RATE_LIMITS.get<RateLimitEntry>(key, 'json');\n  const used = entry?.count || 0;\n  \n  return {\n    allowed: used < limit,\n    used,\n    limit,\n    resetsAt: getTomorrowReset(),\n  };\n}\n\nexport async function incrementUsage(env: Env, deviceId: string): Promise<void> {\n  const key = getTodayKey(deviceId);\n  const entry = await env.RATE_LIMITS.get<RateLimitEntry>(key, 'json');\n  \n  const newEntry: RateLimitEntry = {\n    count: (entry?.count || 0) + 1,\n    date: new Date().toISOString().split('T')[0],\n  };\n  \n  // Expire at end of day (86400 seconds = 24 hours, but we'll set it to expire at midnight UTC + buffer)\n  const ttl = 86400 + 3600; // 25 hours to be safe\n  await env.RATE_LIMITS.put(key, JSON.stringify(newEntry), { expirationTtl: ttl });\n}\n\nexport async function getUsageStats(\n  env: Env,\n  deviceId: string,\n  isPremium: boolean\n): Promise<{ used: number; limit: number; resetsAt: string; isPremium: boolean }> {\n  const { used, limit, resetsAt } = await checkRateLimit(env, deviceId, isPremium);\n  return { used, limit, resetsAt, isPremium };\n}\n", "import { Env, DecomposeRequest, DecomposeResponse, StepDetail } from './types';\n\nconst CACHE_PREFIX = 'decompose:';\n\n// Normalize task for cache key\nfunction normalizeTask(task: string): string {\n  return task\n    .toLowerCase()\n    .trim()\n    .replace(/[^\\w\\s]/g, '')\n    .replace(/\\s+/g, ' ')\n    .substring(0, 100);\n}\n\nfunction getCacheKey(task: string, style: string): string {\n  return `${CACHE_PREFIX}${style}:${normalizeTask(task)}`;\n}\n\nexport async function getCachedResponse(\n  env: Env,\n  task: string,\n  style: string\n): Promise<DecomposeResponse | null> {\n  const key = getCacheKey(task, style);\n  const cached = await env.CACHE.get<DecomposeResponse>(key, 'json');\n  if (cached) {\n    return { ...cached, cached: true };\n  }\n  return null;\n}\n\nexport async function cacheResponse(\n  env: Env,\n  task: string,\n  style: string,\n  response: DecomposeResponse\n): Promise<void> {\n  const key = getCacheKey(task, style);\n  const ttl = parseInt(env.CACHE_TTL_SECONDS) || 86400;\n  await env.CACHE.put(key, JSON.stringify(response), { expirationTtl: ttl });\n}\n\n// System prompts for different styles\nconst JSON_FORMAT = `\nRespond with JSON only:\n{\n  \"title\": \"<short descriptive title for the task>\",\n  \"steps\": [\n    { \"action\": \"<clear action description>\", \"estimatedMinutes\": <minutes for this step> }\n  ],\n  \"encouragement\": \"<brief motivating message>\"\n}`;\n\nconst STYLE_PROMPTS = {\n  standard: `You are an ADHD task coach. Break down the given task into small, actionable steps.\n\nRules:\n- Each step should take 2-10 minutes max\n- Use clear, specific action verbs (grab, open, write, move)\n- Include micro-steps that might seem obvious (ADHD brains need explicit steps)\n- Add brief context/location when helpful\n- 5-8 steps is ideal\n- End with a small reward or acknowledgment step\n- Each step must include a realistic time estimate in minutes\n${JSON_FORMAT}`,\n\n  quick: `You are an ADHD task coach. Break down the given task into exactly 5 quick steps.\n\nRules:\n- Maximum 5 steps, no more\n- Each step ultra-concise (under 10 words)\n- Action verbs only\n- No fluff, just essentials\n- Each step must include a realistic time estimate in minutes\n${JSON_FORMAT}`,\n\n  gentle: `You are a supportive ADHD coach. Break down the given task with extra care and gentleness.\n\nRules:\n- Smaller steps than usual (1-5 minutes each)\n- Include permission to pause between steps\n- Add sensory grounding cues (take a breath, notice your feet)\n- Acknowledge difficulty without judgment\n- Include self-compassion reminders\n- 6-10 steps is fine\n- Each step must include a realistic time estimate in minutes\n${JSON_FORMAT}`,\n};\n\n// Context additions\nfunction getContextAddition(context?: DecomposeRequest['context']): string {\n  if (!context) return '';\n  \n  const additions: string[] = [];\n  \n  if (context.timeOfDay) {\n    const timeHints: Record<string, string> = {\n      morning: 'Consider morning energy levels and routines.',\n      afternoon: 'Account for post-lunch energy dip.',\n      evening: 'Keep steps simple, energy may be low.',\n      night: 'Ultra-simple steps only, minimal cognitive load.',\n    };\n    additions.push(timeHints[context.timeOfDay]);\n  }\n  \n  if (context.energy) {\n    const energyHints: Record<string, string> = {\n      low: 'User has low energy - make steps extra small and gentle.',\n      medium: 'Normal energy level.',\n      high: 'User has good energy - can handle slightly bigger steps.',\n    };\n    additions.push(energyHints[context.energy]);\n  }\n  \n  return additions.length > 0 ? `\\n\\nContext: ${additions.join(' ')}` : '';\n}\n\nexport async function decomposeTask(\n  env: Env,\n  request: DecomposeRequest\n): Promise<DecomposeResponse> {\n  const style = request.style || 'standard';\n  const systemPrompt = STYLE_PROMPTS[style] + getContextAddition(request.context);\n\n  try {\n    const response = await fetch('https://api.openai.com/v1/chat/completions', {\n      method: 'POST',\n      headers: {\n        'Content-Type': 'application/json',\n        'Authorization': `Bearer ${env.OPENAI_API_KEY}`,\n      },\n      body: JSON.stringify({\n        model: 'gpt-4o-mini',\n        messages: [\n          { role: 'system', content: systemPrompt },\n          { role: 'user', content: `Break down this task: ${request.task}` },\n        ],\n        temperature: 0.7,\n        max_tokens: 1000,\n        response_format: { type: 'json_object' },\n      }),\n    });\n\n    if (!response.ok) {\n      const error = await response.text();\n      console.error('OpenAI API error:', error);\n      return {\n        success: false,\n        error: 'AI service temporarily unavailable',\n      };\n    }\n\n    const data = await response.json() as {\n      choices: Array<{ message: { content: string } }>;\n    };\n\n    const content = data.choices[0]?.message?.content;\n    if (!content) {\n      return {\n        success: false,\n        error: 'Empty response from AI',\n      };\n    }\n\n    const parsed = JSON.parse(content);\n\n    // Normalize steps: support both string[] (legacy) and {action, estimatedMinutes}[] formats\n    const steps: StepDetail[] = (parsed.steps || []).map((s: string | { action: string; estimatedMinutes?: number }) => {\n      if (typeof s === 'string') {\n        return { action: s, estimatedMinutes: 5 };\n      }\n      return { action: s.action, estimatedMinutes: s.estimatedMinutes ?? 5 };\n    });\n\n    const totalEstimatedMinutes = steps.reduce((sum: number, s: StepDetail) => sum + s.estimatedMinutes, 0);\n\n    return {\n      success: true,\n      task: {\n        title: parsed.title || request.task,\n        steps,\n        totalEstimatedMinutes,\n        encouragement: parsed.encouragement || 'You\\'ve got this!',\n      },\n      cached: false,\n    };\n  } catch (error) {\n    console.error('Decompose error:', error);\n    return {\n      success: false,\n      error: 'Failed to process task',\n    };\n  }\n}\n\n// Sub-steps prompt for when users are stuck\nconst SUBSTEPS_PROMPT = `You are an ADHD task coach helping someone who is stuck on a step.\n\nBreak this step into 3-5 MICRO-steps that are:\n- Extremely small (1-3 minutes each)\n- Physical and concrete (stand up, open app, move hand)\n- Include the very first tiny action to start\n- No thinking or decision-making required\n\nThe goal is to make starting feel effortless.\n\nRespond with JSON only:\n{\n  \"substeps\": [\"micro-step 1\", \"micro-step 2\", ...],\n  \"encouragement\": \"<brief, warm encouragement>\"\n}`;\n\nexport async function getSubSteps(\n  env: Env,\n  step: string,\n  taskContext?: string\n): Promise<{ success: boolean; substeps?: string[]; encouragement?: string; error?: string }> {\n  const userMessage = taskContext \n    ? `Task context: ${taskContext}\\n\\nStep I'm stuck on: ${step}`\n    : `Step I'm stuck on: ${step}`;\n\n  try {\n    const response = await fetch('https://api.openai.com/v1/chat/completions', {\n      method: 'POST',\n      headers: {\n        'Content-Type': 'application/json',\n        'Authorization': `Bearer ${env.OPENAI_API_KEY}`,\n      },\n      body: JSON.stringify({\n        model: 'gpt-4o-mini',\n        messages: [\n          { role: 'system', content: SUBSTEPS_PROMPT },\n          { role: 'user', content: userMessage },\n        ],\n        temperature: 0.7,\n        max_tokens: 500,\n        response_format: { type: 'json_object' },\n      }),\n    });\n\n    if (!response.ok) {\n      const error = await response.text();\n      console.error('OpenAI API error:', error);\n      return {\n        success: false,\n        error: 'AI service temporarily unavailable',\n      };\n    }\n\n    const data = await response.json() as {\n      choices: Array<{ message: { content: string } }>;\n    };\n\n    const content = data.choices[0]?.message?.content;\n    if (!content) {\n      return {\n        success: false,\n        error: 'Empty response from AI',\n      };\n    }\n\n    const parsed = JSON.parse(content);\n    return {\n      success: true,\n      substeps: parsed.substeps,\n      encouragement: parsed.encouragement,\n    };\n  } catch (error) {\n    console.error('SubSteps error:', error);\n    return {\n      success: false,\n      error: 'Failed to break down step',\n    };\n  }\n}\n", "import { Env, TokenPayload, DecomposeRequest, DecomposeResponse, UsageResponse } from './types';\nimport { createToken, verifyToken, generateDeviceId } from './auth';\nimport { checkRateLimit, incrementUsage, getUsageStats } from './ratelimit';\nimport { getCachedResponse, cacheResponse, decomposeTask, getSubSteps } from './openai';\n\n// CORS headers\nconst corsHeaders = {\n  'Access-Control-Allow-Origin': '*',\n  'Access-Control-Allow-Methods': 'GET, POST, OPTIONS',\n  'Access-Control-Allow-Headers': 'Content-Type, Authorization',\n  'Access-Control-Max-Age': '86400',\n};\n\nfunction jsonResponse(data: unknown, status = 200): Response {\n  return new Response(JSON.stringify(data), {\n    status,\n    headers: {\n      'Content-Type': 'application/json',\n      ...corsHeaders,\n    },\n  });\n}\n\nfunction errorResponse(message: string, status = 400): Response {\n  return jsonResponse({ success: false, error: message }, status);\n}\n\n// Extract and verify auth token\nasync function authenticate(request: Request, env: Env): Promise<TokenPayload | null> {\n  const authHeader = request.headers.get('Authorization');\n  if (!authHeader?.startsWith('Bearer ')) {\n    return null;\n  }\n\n  const token = authHeader.slice(7);\n  return verifyToken(token, env.JWT_SECRET);\n}\n\n// Validate decompose request\nfunction validateDecomposeRequest(body: unknown): DecomposeRequest | null {\n  if (!body || typeof body !== 'object') return null;\n  \n  const req = body as Record<string, unknown>;\n  \n  if (typeof req.task !== 'string' || req.task.trim().length === 0) {\n    return null;\n  }\n  \n  if (req.task.length > 500) {\n    return null;\n  }\n  \n  const style = req.style as string | undefined;\n  if (style && !['standard', 'quick', 'gentle'].includes(style)) {\n    return null;\n  }\n  \n  return {\n    task: req.task.trim(),\n    style: (style as DecomposeRequest['style']) || 'standard',\n    context: req.context as DecomposeRequest['context'],\n  };\n}\n\n// Route handlers\nasync function handleRegister(env: Env): Promise<Response> {\n  const deviceId = generateDeviceId();\n  const token = await createToken({ deviceId, isPremium: false }, env.JWT_SECRET);\n  \n  return jsonResponse({\n    success: true,\n    token,\n    deviceId,\n  });\n}\n\nasync function handleDecompose(request: Request, env: Env): Promise<Response> {\n  // Authenticate\n  const auth = await authenticate(request, env);\n  if (!auth) {\n    return errorResponse('Unauthorized', 401);\n  }\n\n  // Parse request body\n  let body: unknown;\n  try {\n    body = await request.json();\n  } catch {\n    return errorResponse('Invalid JSON body');\n  }\n\n  // Validate request\n  const decomposeReq = validateDecomposeRequest(body);\n  if (!decomposeReq) {\n    return errorResponse('Invalid request: task is required (max 500 chars)');\n  }\n\n  // Check rate limit\n  const rateLimit = await checkRateLimit(env, auth.deviceId, auth.isPremium);\n  if (!rateLimit.allowed) {\n    return jsonResponse({\n      success: false,\n      error: 'Daily limit reached',\n      usage: {\n        used: rateLimit.used,\n        limit: rateLimit.limit,\n        resetsAt: rateLimit.resetsAt,\n      },\n    }, 429);\n  }\n\n  // Check cache first\n  const cached = await getCachedResponse(env, decomposeReq.task, decomposeReq.style || 'standard');\n  if (cached) {\n    // Still count against rate limit for free users (prevents cache farming)\n    if (!auth.isPremium) {\n      await incrementUsage(env, auth.deviceId);\n    }\n    return jsonResponse(cached);\n  }\n\n  // Call OpenAI\n  const result = await decomposeTask(env, decomposeReq);\n  \n  if (result.success) {\n    // Cache successful response\n    await cacheResponse(env, decomposeReq.task, decomposeReq.style || 'standard', result);\n    \n    // Increment usage\n    if (!auth.isPremium) {\n      await incrementUsage(env, auth.deviceId);\n    }\n  }\n\n  return jsonResponse(result);\n}\n\nasync function handleUsage(request: Request, env: Env): Promise<Response> {\n  const auth = await authenticate(request, env);\n  if (!auth) {\n    return errorResponse('Unauthorized', 401);\n  }\n\n  const stats = await getUsageStats(env, auth.deviceId, auth.isPremium);\n  return jsonResponse(stats);\n}\n\nasync function handleVerifySubscription(request: Request, env: Env): Promise<Response> {\n  const auth = await authenticate(request, env);\n  if (!auth) {\n    return errorResponse('Unauthorized', 401);\n  }\n\n  // Parse RevenueCat user ID from body\n  let body: { revenueCatUserId?: string };\n  try {\n    body = await request.json();\n  } catch {\n    return errorResponse('Invalid JSON body');\n  }\n\n  // TODO: Verify with RevenueCat API\n  // For now, just return current status\n  // In production, you'd call RevenueCat to verify subscription\n  \n  return jsonResponse({\n    success: true,\n    isPremium: auth.isPremium,\n    message: 'RevenueCat verification not yet implemented',\n  });\n}\n\nasync function handleUpgradeToPremium(request: Request, env: Env): Promise<Response> {\n  const auth = await authenticate(request, env);\n  if (!auth) {\n    return errorResponse('Unauthorized', 401);\n  }\n\n  // Generate new token with premium status\n  // In production, only do this after RevenueCat webhook confirms purchase\n  const newToken = await createToken(\n    { deviceId: auth.deviceId, isPremium: true, userId: auth.userId },\n    env.JWT_SECRET\n  );\n\n  return jsonResponse({\n    success: true,\n    token: newToken,\n    isPremium: true,\n  });\n}\n\nasync function handleSubSteps(request: Request, env: Env): Promise<Response> {\n  // Authenticate\n  const auth = await authenticate(request, env);\n  if (!auth) {\n    return errorResponse('Unauthorized', 401);\n  }\n\n  // Parse request body\n  let body: { step: string; taskContext?: string };\n  try {\n    body = await request.json();\n  } catch {\n    return errorResponse('Invalid JSON body');\n  }\n\n  if (!body.step || typeof body.step !== 'string' || body.step.trim().length === 0) {\n    return errorResponse('Invalid request: step is required');\n  }\n\n  if (body.step.length > 300) {\n    return errorResponse('Step text too long (max 300 chars)');\n  }\n\n  // Call OpenAI for sub-steps\n  const result = await getSubSteps(env, body.step.trim(), body.taskContext);\n  \n  return jsonResponse(result);\n}\n\nasync function handleHealth(): Promise<Response> {\n  return jsonResponse({\n    status: 'healthy',\n    timestamp: new Date().toISOString(),\n  });\n}\n\n// Main router\nexport default {\n  async fetch(request: Request, env: Env): Promise<Response> {\n    // Handle CORS preflight\n    if (request.method === 'OPTIONS') {\n      return new Response(null, { headers: corsHeaders });\n    }\n\n    const url = new URL(request.url);\n    const path = url.pathname;\n\n    try {\n      // Health check\n      if (path === '/health' && request.method === 'GET') {\n        return handleHealth();\n      }\n\n      // Register new device (get token)\n      if (path === '/v1/register' && request.method === 'POST') {\n        return handleRegister(env);\n      }\n\n      // Decompose task\n      if (path === '/v1/decompose' && request.method === 'POST') {\n        return handleDecompose(request, env);\n      }\n\n      // Get usage stats\n      if (path === '/v1/usage' && request.method === 'GET') {\n        return handleUsage(request, env);\n      }\n\n      // Verify subscription status\n      if (path === '/v1/verify-subscription' && request.method === 'POST') {\n        return handleVerifySubscription(request, env);\n      }\n\n      // Get sub-steps for a stuck step\n      if (path === '/v1/substeps' && request.method === 'POST') {\n        return handleSubSteps(request, env);\n      }\n\n      // Webhook for RevenueCat (premium upgrade)\n      if (path === '/v1/webhook/revenuecat' && request.method === 'POST') {\n        return handleUpgradeToPremium(request, env);\n      }\n\n      // Not found\n      return errorResponse('Not found', 404);\n    } catch (error) {\n      console.error('Unhandled error:', error);\n      return errorResponse('Internal server error', 500);\n    }\n  },\n};\n"],
  "mappings": "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",
  "names": []
}
